<?php
	
	namespace App\Helpers\Traits;
	
	use App\Entity\Ansprechform;
	use App\Entity\Geschlecht;
	use App\Entity\KnowledgeEintrag;
	use App\Entity\KnowledgeKategorie;
	use App\Entity\Personen;
	use App\Entity\PersonenKategorie;
	use App\Entity\ProdukteKategorie;
	use App\Entity\RechnungPs;
	use App\Entity\RechnungStatus;
	use App\Entity\TicketPrio;
	use App\Entity\TicketStatus;
	use App\Entity\TicketTyp;
	use App\Entity\Zahlungsmittel;
	use App\Helpers\Date\RequestBridge;
	use Doctrine\ORM\EntityRepository;
	use Doctrine\ORM\EntityManagerInterface;
	use Symfony\Component\Security\Core\User\UserInterface;
	
	/**
	 * EntityFieldMapperTrait
	 * Entity Field-Mapper Trait automatically generated by Poiz Doctrine
	 * Mediator. You may add additional Methods to this Trait...
	 **/
	trait EntityFieldMapperTrait {
		
		/**
		 * @var array
		 */
		private $classProps = [];
		
		/**
		 * #@var array
		 */
		# private $entityBank = [];
		
		/**
		 * @return bool
		 */
		public function isDeleted() {
			return $this->deleted;
		}
		
		/**
		 * @return bool
		 */
		public function getDeleted() {
			return $this->deleted;
		}
		
		/**
		 * @param bool $deleted
		 */
		public function setDeleted( $deleted ) {
			$this->deleted = $deleted;
		}
		
		
		/**
		 *
		 * @return string
		 */
		public function __toString() {
			return json_encode( array_merge( [ 'className' => get_class( $this ) ], $this->toArray( true ) ) );
		}
		
		public function toArray( $addClassName = false, $bypassedFields = [] ) {
			$bypassedFields = array_merge( [
				'entityBank',
				'classProps',
			], $bypassedFields );
			$returnArray    = $addClassName ? [ 'className' => get_class( $this ) ] : [];
			foreach ( get_object_vars( $this ) as $property => $value ) {
				if ( $bypassedFields && in_array( $property, $bypassedFields ) ) {
					continue;
				}
				if ( ! property_exists( get_class( $this ), $property ) ) {
					continue;
				}
				$prop = new \ReflectionProperty( get_class( $this ), $property );
				// IF THE PROPERTY TYPE IS MULTILINGUAL-STRING JUST RETURN THE JSON DECODED VALUE
				$propType = array_filter( explode( "
", $prop->getDocComment() ), function ( $val ) {
					return stristr( $val, "@var" );
				} );
				$propType = current( array_map( function ( $val ) {
					return trim( preg_replace( "#\*\s*?@var\s*#", '', $val ) );
				}, $propType ) );
				
				if ( $propType === 'MultilingualString' ) {
					$returnArray[ $property ] = json_decode( $value );
				} else {
					$get = $this->siftGetterMethod( $property );
					if ( $get ) {
						$returnArray[ $property ] = $this->{$get}();
					}
				}
			}
			
			return $returnArray;
		}
		
		public function toShallowArray() {
			return array_merge( [ 'className' => get_class( $this ) ], get_object_vars( $this ) );
		}
		
		public function map( $arrayOrObject ) {
			foreach ( $arrayOrObject as $property => $value ) {
				$value = is_object( $value ) ? $value : ( ( strtolower( $value ) == 'true' ) ? true : ( strtolower( $value ) == 'false' ? false : $value ) );
				if ( property_exists( $this, $property ) ) {
					$set = $this->siftSetterMethod( $property );
					if ( is_string( $set ) ) {
						$this->{$set}( $value );
					}
				}
			}
			
			return $this;
		}
		
		protected function siftSetterMethod( $property ) {
			$classMethods = ( new \ReflectionClass( $this ) )->getMethods( \ReflectionMethod::IS_PUBLIC );
			// CYCLE THROUGH THE CLASS METHODS AND SIFT OUT THE SETTER METHOD.
			/** @var \ReflectionMethod $classMethod */
			foreach ( $classMethods as $classMethod ) {
				if ( preg_match( "#^set#", $classMethod->getName() ) &&
				     # stristr( $classMethod->getName(), preg_replace("#_#", "", $property) ) ) {
				     preg_replace( "#^set#", "", strtolower($classMethod->getName())) == preg_replace("#_#", "", strtolower($property)) ) {
					return $classMethod->name;
				}
			}
			
			return false;
		}
		
		protected function siftGetterMethod( $property ) {
			$classMethods = ( new \ReflectionClass( $this ) )->getMethods( \ReflectionMethod::IS_PUBLIC );
			// CYCLE THROUGH THE CLASS METHODS AND SIFT OUT THE SETTER METHOD.
			/** @var \ReflectionMethod $classMethod */
			foreach ( $classMethods as $classMethod ) {
				$getterSansAccessor = preg_replace( [
					"#^is#",
					"#^get#",
				], '', strtolower( $classMethod->getName() ) );
				if ( ( preg_match( "#^is#", $classMethod->getName() ) ||
				       preg_match( "#^get#", $classMethod->getName() ) ) &&
				     ( $getterSansAccessor === strtolower( $property ) ) ) {
					return $classMethod->name;
				}
			}
			
			return false;
		}
		
		protected function siftGetSetMethod( $property, $type = "get" ) {
			// WITHOUT A FILTER EG: `\ReflectionMethod::IS_PUBLIC`, YOU'D GET STATIC METHODS AS WELL...
			$classMethods = ( new \ReflectionClass( $this ) )->getMethods();
			// CYCLE THROUGH THE CLASS METHODS AND SIFT OUT THE SETTER METHOD.
			/** @var \ReflectionMethod $classMethod */
			foreach ( $classMethods as $classMethod ) {
				if ( strtolower( $type === "get" ) ) {
					$getterSansAccessor = preg_replace( [
						"#^is#",
						"#^get#",
					], '', strtolower( $classMethod->getName() ) );
					if ( preg_match( "#(^is|^get)#", $classMethod->getName() ) &&
					     ( $getterSansAccessor === strtolower( $property ) ) ) {
						if ( $classMethod->isStatic() ) {
							return [
								'method' => $classMethod->name,
								'static' => true,
							];
						}
						
						return $classMethod->name;
					}
				} else if ( strtolower( $type === "set" ) ) {
					$setterSansAccessor = preg_replace( "#^set#", '', strtolower( $classMethod->getName() ) );
					if ( preg_match( "#(^set)#", $classMethod->getName() ) &&
					     ( $setterSansAccessor === strtolower( $property ) ) ) {
						if ( $classMethod->isStatic() ) {
							return [
								'method' => $classMethod->name,
								'static' => true,
							];
						}
						
						return $classMethod->name;
					}
				}
			}
			
			return false;
		}
		
		public function __get( $name ) {
			try {
				
				if ( property_exists( $this, $name ) ) {
					return $this->$name;
				} else {
					if ( isset( $this->entityBank ) && $this->entityBank ) {
						if ( array_key_exists( $name, $this->entityBank ) ) {
							return $this->entityBank[ $name ];
						}
					}
				}
			} catch ( \Exception $e ) {
				return null;
			}
			
			return null;
		}
		
		public function __set( $name, $value ) {
			if ( property_exists( $this, $name ) ) {
				$this->$name = $value;
				if ( $name == 'entityBank' ) {
					if ( ! empty( $value ) ) {
						$this->autoSetClassProps( $value );
					}
				} else {
					$this->entityBank[ $name ] = $value;
				}
			} else {
				$this->entityBank[ $name ] = $value;
			}
			
			return $this;
		}
		
		public function objectToArrayRecursive( $object, &$return_array = null ) {
			if ( ! is_object( $object ) || empty( $object ) ) {
				return null;
			}
			$return_array = ( ! $return_array ) ? [] : $return_array;
			foreach ( $object as $key => $val ) {
				if ( is_object( $val ) ) {
					$return_array[ $key ] = [];
					$this->objectToArrayRecursive( $val, $return_array[ $key ] );
				} else {
					$return_array[ $key ] = $val;
				}
			}
			
			return $return_array;
		}
		
		public function arrayToObjectRecursive( $array, &$objReturn = null ) {
			if ( ! is_array( $array ) || empty( $array ) ) {
				return null;
			}
			$objReturn = ( ! $objReturn ) ? new \stdClass() : $objReturn;
			foreach ( $array as $key => $val ) {
				if ( is_array( $val ) ) {
					$objReturn->$key = new \stdClass();
					$this->arrayToObjectRecursive( $val, $objReturn->$key );
				} else {
					$objReturn->$key = $val;
				}
			}
			
			return $objReturn;
		}
		
		public function recursiveArrayFind( $key, $data ) {
			if ( array_key_exists( $key, $data ) ) {
				return $data[ $key ];
			} else {
				if ( is_array( $data ) ) {
					foreach ( $data as $k => $value ) {
						if ( $k == $key ) {
							return $value;
						} else if ( is_array( $value ) ) {
							return $this->recursiveArrayFind( $key, $value );
						}
					}
				}
			}
			
			return null;
		}
		
		public function generateRandomHash( $length = 6 ) {
			$characters   = '0123456789ABCDEF';
			$randomString = '';
			
			for ( $i = 0; $i < $length; $i ++ ) {
				$randomString .= $characters[ rand( 0, strlen( $characters ) - 1 ) ];
			}
			
			return $randomString;
		}
		
		public static function getToggleSwitchOptions() {
			return [
				0 => 'No',
				1 => 'Yes',
			];
		}
		
		public static function findInArrayRecursive( $array, $val, &$rayKeyMap = [], &$rayReturns = [] ) {
			$returnData = [];
			foreach ( $array as $key => $value ) {
				if ( is_array( $value ) ) {
					$rayKeyMap[] = $key;
					
					return static::findInArrayRecursive( $value, $val, $rayKeyMap, $rayReturns );
				}
				if ( $val == $value ) {
					$rayKeyMap[]  = $key;
					$rayReturns[] = $rayKeyMap;
					array_pop( $rayKeyMap );
				}
			}
			if ( $rayReturns ) {
				$returnData = [];
				foreach ( $rayReturns as $iKey => $rayKeys ) {
					$returnData[] = implode( ".", $rayKeys );
				}
			}
			
			return $returnData;
		}
		
		public static function fetchDataFromArrayDotSyntax( $array, $dotPath = "" ) {
			if ( ! $dotPath ) {
				return $array;
			}
			$parts      = explode( ".", $dotPath );
			$arrayClone = $array;
			foreach ( $parts as $iKey => $part ) {
				$arrayClone = isset( $arrayClone[ $part ] ) ? $arrayClone[ $part ] : false;
			}
			
			return $arrayClone;
		}
		
		
		
		public static function FetchSwitchConfig($opt){
			return static::$toggleConfig;
		}
		
		public static function FetchFunktionenAsOptions(){
			/** @var \Doctrine\ORM\EntityManager $entityManager */
			/** @var \App\Entity\PersonenKategorie $personCategory */
			global $kernel;
			$entityManager        = $kernel->getContainer()->get('doctrine.orm.entity_manager');
			$rayPersonCategories  = [];
			$personCategories     = $entityManager->
			getRepository(PersonenKategorie::class)->findBy([], ['personen_kategorie_name'=>'ASC']);
			if($personCategories){
				# $rayPersonCategories[""] = "Personen Kategorie wählen...";
				foreach($personCategories as $personCategory){
					$rayPersonCategories[$personCategory->getPersonenKategorieId()] = $personCategory->getPersonenKategorieName();
				}
			}
			return $rayPersonCategories;
		}
		
		public static function FetchGeschlechtAsOptions(){
			/** @var \Doctrine\ORM\EntityManager $entityManager */
			/** @var \App\Entity\Geschlecht $gender */
			global $kernel;
			$entityManager    = $kernel->getContainer()->get('doctrine.orm.entity_manager');
			$rayGender        = [];
			$genderData       = $entityManager->
			getRepository(Geschlecht::class)->findBy([], ['Geschlecht_name'=>'ASC']);
			if($genderData){
				foreach($genderData as $gender){
					$rayGender[$gender->getGeschlechtId()] = $gender->getGeschlechtName();
				}
			}
			return $rayGender;
		}
		
		public static function FetchAnsprechformAsOptions(){
			/** @var \Doctrine\ORM\EntityManager $entityManager */
			/** @var \App\Entity\Ansprechform $addressForm */
			global $kernel;
			$entityManager    = $kernel->getContainer()->get('doctrine.orm.entity_manager');
			$rayAddressForm   = [];
			$addressFormData  = $entityManager->
			getRepository(Ansprechform::class)->findBy([], ['Ansprechform_name'=>'ASC']);
			if($addressFormData){
				foreach($addressFormData as $addressForm){
					$rayAddressForm[$addressForm->getAnsprechformId()] = $addressForm->getAnsprechformName();
				}
			}
			return $rayAddressForm;
		}
		
		public static function fetchTicketStatusAsOptions(){
			/** @var \Doctrine\ORM\EntityManager $entityManager */
			/** @var \App\Entity\TicketStatus $ticketStatus */
			global $kernel;
			$entityManager        = $kernel->getContainer()->get('doctrine.orm.entity_manager');
			$rayTicketStatuses    = [];
			$ticketStatuses       = $entityManager->
			getRepository(TicketStatus::class)->findBy([], ['ticket_status_id'=>'ASC']);  // ticket_status_name  ticket_status_id
			if($ticketStatuses){
				$rayTicketStatuses[" "] = "Ticket Status wählen...";   // ADDED TO HAVE A FALL-BACK EMPTY VALUE...
				foreach($ticketStatuses as $ticketStatus){
					$rayTicketStatuses[$ticketStatus->getTicketStatusId()] = $ticketStatus->getTicketStatusName();
				}
			}
			return $rayTicketStatuses;
		}
		
		public static function fetchTicketPrioritiesAsOptions(){
			/** @var \Doctrine\ORM\EntityManager $entityManager */
			/** @var \App\Entity\TicketPrio $ticketPriority */
			global $kernel;
			$entityManager        = $kernel->getContainer()->get('doctrine.orm.entity_manager');
			$rayTicketPriorities  = [];
			$ticketPriorities     = $entityManager->
			getRepository(TicketPrio::class)->findBy([], ['ticket_prio_id'=>'ASC']);  // ticket_prio_name  ticket_prio_id
			if($ticketPriorities){
				# $rayTicketPriorities[""] = "Priorität wählen...";
				foreach($ticketPriorities as $ticketPriority){
					$rayTicketPriorities[$ticketPriority->getTicketPrioId()] = $ticketPriority->getTicketPrioName();
				}
			}
			return $rayTicketPriorities;
		}
		
		public static function fetchTicketTypesAsOptions(){
			/** @var \Doctrine\ORM\EntityManager $entityManager */
			/** @var \App\Entity\TicketTyp $ticketType */
			global $kernel;
			$entityManager        = $kernel->getContainer()->get('doctrine.orm.entity_manager');
			$rayTicketTypes       = [];
			$ticketTypes          = $entityManager->
			getRepository(TicketTyp::class)->findBy([], ['ticket_typ_id'=>'ASC']);  // ticket_typ_name  ticket_typ_id
			if($ticketTypes){
				$rayTicketTypes[" "] = "Typ wählen...";    // ADDED TO HAVE A FALL-BACK EMPTY VALUE...
				foreach($ticketTypes as $ticketType){
					$rayTicketTypes[$ticketType->getTicketTypId()] = $ticketType->getTicketTypName();
				}
			}
			return $rayTicketTypes;
		}
		
		public static function fetchPrivateClientsAsOptions(){
			# TODO 3 IS NO LONGER VALID AS `Mitarbeiter`: USE 10 AND CONSIDER DELETING 3 COMPLETELY
			# TODO: ['1' => 'Privatkunde', '2' => 'Geschäftskunde', '3' => 'Mitarbeiter', '4' => 'Lieferant', '5' => 'Blumen-Lieferant', '6' => 'Tool-user', '10' => 'Mitarbeiter', ]
			return static::fetchDataFromPersonTableAsOptions(['1'],
				['vorname'=>'ASC', 'name'=>'ASC', 'Firma' => 'ASC'],
				['ps.vorname'=>'', 'ps.name'=>'']
			) ;
		}
		
		public static function fetchCompanyAndPrivateClientsAsOptions(){
			# TODO 3 IS NO LONGER VALID AS `Mitarbeiter`: USE 10 AND CONSIDER DELETING 3 COMPLETELY
			# TODO: ['1' => 'Privatkunde', '2' => 'Geschäftskunde', '3' => 'Mitarbeiter', '4' => 'Lieferant', '5' => 'Blumen-Lieferant', '6' => 'Tool-user', '10' => 'Mitarbeiter', ]
			# return static::fetchDataFromPersonTableAsOptions(['1', '2'], ['Firma' => 'ASC', 'vorname'=>'ASC', 'name'=>'ASC']) ;
			$companyClients = static::fetchDataFromPersonTableAsOptions(['2'], ['Firma' => 'ASC', 'vorname'=>'ASC', 'name'=>'ASC']) ;
			$privateClients = static::fetchDataFromPersonTableAsOptions(['1'],
				['vorname'=>'ASC', 'name'=>'ASC', 'Firma' => 'ASC'],
				['ps.vorname'=>'', 'ps.name'=>'']
			) ;
			return array_merge($companyClients, $privateClients);
			
			
		}
		
		public static function fetchCompanyClientsAsOptions(){
			# TODO 3 IS NO LONGER VALID AS `Mitarbeiter`: USE 10 AND CONSIDER DELETING 3 COMPLETELY
			# TODO: ['1' => 'Privatkunde', '2' => 'Geschäftskunde', '3' => 'Mitarbeiter', '4' => 'Lieferant', '5' => 'Blumen-Lieferant', '6' => 'Tool-user', '10' => 'Mitarbeiter', ]
			return static::fetchDataFromPersonTableAsOptions(['2'], ['Firma' => 'ASC', 'vorname'=>'ASC', 'name'=>'ASC']) ;
		}
		
		public static function fetchPaymentMethodsAsOptions(){
			/** @var \Doctrine\ORM\EntityManager $entityManager */
			/** @var Zahlungsmittel $paymentMethod */
			global $kernel;
			$entityManager    = $kernel->getContainer()->get('doctrine.orm.entity_manager');
			$resultSet        = $entityManager->getRepository(Zahlungsmittel::class)->findBy([], [ 'Zahlungsmittel_Reihenfolge' => 'ASC']);
			$returnData       = [];
			
			if($resultSet){
				foreach ($resultSet as $key=>$paymentMethod){
					$returnData[$paymentMethod->getZahlungsmittelId() . " "]    = $paymentMethod->getZahlungsmittelName();
				}
			}
			return $returnData;
		}
		
		public static function fetchPaymentMethodsAsOptionsWithoutCash(){
			/** @var \Doctrine\ORM\EntityManager $entityManager */
			/** @var Zahlungsmittel $paymentMethod */
			global $kernel;
			$entityManager    = $kernel->getContainer()->get('doctrine.orm.entity_manager');
			$resultSet        = $entityManager->getRepository(Zahlungsmittel::class)->findBy([], [ 'Zahlungsmittel_Reihenfolge' => 'ASC']);
			$returnData       = [];
			
			if($resultSet){
				foreach ($resultSet as $key=>$paymentMethod){
					if (in_array($paymentMethod->getZahlungsmittelId(), ['1', '10'])) { continue; }
					$returnData[$paymentMethod->getZahlungsmittelId() . " "]    = $paymentMethod->getZahlungsmittelName();
				}
			}
			return $returnData;
		}
		
		public static function fetchBillRecapPaymentMethodsAsOptions(){
			return [
				'1010 '  => 'Zahlung auf Postkonto',
				'1000 '  => 'Barzahlung',
				'1105 '  => 'Kartenzahlung',
			];
		}
		
		public static function fetchAccountsAsOptions(){
			/** @var \Doctrine\ORM\EntityManager $entityManager */
			/** @var Zahlungsmittel $paymentMethod */
			global $kernel;
			$entityManager    = $kernel->getContainer()->get('doctrine.orm.entity_manager');
			$conn             = $entityManager->getConnection();
			$sql              = "SELECT  BH_Konto_Nummer, BH_Konto_name
														FROM BH_Konto
														WHERE BH_Konto_Nummer
														IN (1525, 6210, 4000, 4010, 4200, 4210,
																4220, 4240, 4420, 5030, 6100, 6220,
																6410, 6500, 6510, 6530, 6570, 6650, 6610)
														ORDER BY BH_Konto_name ASC";
			$stm              = $conn->prepare($sql);
			$stm->execute();
			$resultSet        = $stm->fetchAll();
			$returnData       = [];
			
			if($resultSet){
				foreach ($resultSet as $key=>$account){
					$returnData[$account['BH_Konto_Nummer'] . " "]    = $account['BH_Konto_name'];
				}
			}
			return $returnData;
		}
		
		public static function  fetchProductCategoriesAsOptions(){
			/** @var \Doctrine\ORM\EntityManager $entityManager */
			/** @var ProdukteKategorie $productCat */
			global $kernel;
			$entityManager    = $kernel->getContainer()->get('doctrine.orm.entity_manager');
			$resultSet        = $entityManager->getRepository(ProdukteKategorie::class)->findBy([], [ 'kat_name' => 'ASC']);
			$returnData       = [];
			
			if($resultSet){
				foreach ($resultSet as $key=>$productCat){
					$returnData[$productCat->getProduktekategorieBHKonto()  . " "]    = $productCat->getKatName();
				}
			}
			return $returnData;
		}
		
		public static function  fetchProductCategoriesForEssenzaAsOptions(){
			/** @var \Doctrine\ORM\EntityManager $entityManager */
			/** @var ProdukteKategorie $productCat */
			global $kernel;
			$entityManager    = $kernel->getContainer()->get('doctrine.orm.entity_manager');
			$sessionObject    = $kernel->getContainer()->get('session');
			$resultSet        = $entityManager->getRepository(ProdukteKategorie::class)->findBy([], [ 'kat_name' => 'ASC']);
			$returnData       = [];
			$melSession       = $sessionObject->get(RequestBridge::SessionNameSpace, []);
			$user             = isset($melSession['user']) ? $melSession['user'] : null;
			
			
			if($resultSet){
				foreach ($resultSet as $key=>$productCat){
					if(in_array($user->getPersonId(), ["940", "941", "2621"])){
						if($productCat->getProduktekategorieBHKonto() == "3270"){
							$returnData[$productCat->getProduktekategorieBHKonto()  . " "]    = $productCat->getKatName();
							break;
						}
					}else{
						$returnData[$productCat->getProduktekategorieBHKonto()  . " "]    = $productCat->getKatName();
					}
				}
			}
			return $returnData;
		}
		
		public static function fetchEmptyProductsAsOptions(){
			return [''=>'Produktkategorie zuerst wählen'];
			/** @var \Doctrine\ORM\EntityManager $entityManager */
			/** @var Zahlungsmittel $paymentMethod */
			global $kernel;
			$entityManager    = $kernel->getContainer()->get('doctrine.orm.entity_manager');
			$resultSet        = $entityManager->getRepository(Zahlungsmittel::class)->findBy([], [ 'Zahlungsmittel_name' => 'ASC']);
			$returnData       = [];
			
			if($resultSet){
				foreach ($resultSet as $key=>$paymentMethod){
					$returnData[$paymentMethod->getZahlungsmittelId() . " "]    = $paymentMethod->getZahlungsmittelName();
				}
			}
			return $returnData;
		}
		
		public static function fetchKnowledgeDataAsOptions(){
			/** @var \Doctrine\ORM\EntityManager $entityManager */
			/** @var KnowledgeKategorie $knowledgeCat */
			/** @var KnowledgeEintrag $entry */
			global $kernel;
			$entityManager    = $kernel->getContainer()->get('doctrine.orm.entity_manager');
			$qb               = $entityManager->getConnection()->createQueryBuilder();
			$or               = $qb->expr()->orX();
			$returnData       = ["" => "Wissensdatenbank-Eintrag auswählen"]; // knowledge_kategoriename ASC
			$knowledgeCats    = $entityManager->getRepository(KnowledgeKategorie::class)
			                                  ->findBy([], ['knowledge_kategoriename'=>'ASC']);
			if($knowledgeCats){
				foreach($knowledgeCats as $iKey=>$knowledgeCat){
					$returnData["{$iKey}@@@"]    = '--- ' . $knowledgeCat->getKnowledgeKategoriename() . ' ---';
					$knowledgeEntries4Category    = $entityManager->getRepository(KnowledgeEintrag::class)->findBy(['knowledge_eintrag_katID' => $knowledgeCat->getKnowledgeKategorieID()], ['knowledge_eintragfrage'=>'ASC']);
					if($knowledgeEntries4Category){
						foreach ($knowledgeEntries4Category as $entry){
							$returnData[$entry->getKnowledgeEintragID() . " "]    = $entry->getKnowledgeEintragfrage();
						}
					}
				}
			}
			# dump($returnData);
			return $returnData;
		}
		
		public static function fetchKnowledgeCategoriesAsOptions(){
			/** @var \Doctrine\ORM\EntityManager $entityManager */
			/** @var KnowledgeKategorie $knowledgeCat */
			/** @var KnowledgeEintrag $entry */
			global $kernel;
			$entityManager    = $kernel->getContainer()->get('doctrine.orm.entity_manager');
			$returnData       = [];
			$knowledgeCats    = $entityManager->getRepository(KnowledgeKategorie::class)
			                                  ->findBy([], ['knowledge_kategoriename'=>'ASC']);
			if($knowledgeCats){
				foreach($knowledgeCats as $iKey=>$knowledgeCat){
					$returnData[$knowledgeCat->getKnowledgeKategorieID() . " "] = $knowledgeCat->getKnowledgeKategoriename();
				}
			}
			return $returnData;
		}
		
		public static function fetchDataFromPersonTableAsOptions($rayPersonCategoryIDs, $rayOrder=['vorname' => 'ASC', 'name'=>'ASC', 'Firma'=>'ASC'], $extraAnd=[]){
			/** @var \Doctrine\ORM\EntityManager $entityManager */
			global $kernel;
			$entityManager    = $kernel->getContainer()->get('doctrine.orm.entity_manager');
			$qb               = $entityManager->getConnection()->createQueryBuilder();
			$or               = $qb->expr()->orX();
			$returnData       = [];
			
			
			foreach($rayPersonCategoryIDs as $categoryID){
				$or->add($qb->expr()->eq('ps.Kategorie', $qb->expr()->literal($categoryID)));
			}
			$qb->select('ps.*')
			   ->from('personen', 'ps')
			   ->leftJoin('ps', 'personen_kategorie', 'pk', 'ps.Kategorie=pk.personen_kategorie_id')
			   ->where($or);
			
			if($extraAnd){
				$and           = $qb->expr()->andX();
				foreach($extraAnd as $fieldName=>$extraPlus){
					$and->add($qb->expr()->neq($fieldName, $qb->expr()->literal($extraPlus)));
					$and->add($qb->expr()->isNotNull($fieldName));
				}
				$qb->andWhere($and);
			}
			if($rayOrder){
				foreach($rayOrder as $order=>$direction){
					$qb->addOrderBy($order, $direction);
				}
			}
			# dump(debug_backtrace());
			# dump($rayOrder);
			# dump($qb->getSQL());
			$resultSet = $qb->execute()->fetchAll();
			
			if($resultSet){
				$returnData[" "]    = "Bitte wählen...";    // ADDED TO HAVE A FALL-BACK EMPTY VALUE...
				foreach ($resultSet as $key=>$client){
					$cName                              = ($fm = $client['Firma']) ? $fm : "";
					$pName                              = ($n = $client['name']) ? $n  : "";
					$pName                              = ($f = $client['vorname']) ?  trim($f) . " " . trim($pName) : "";
					$cName                              = $cName ? $cName . ( ($pName ? " -- " . $pName : "") ) : ($pName ? $pName : $cName);
					$cName                              = $extraAnd ? trim($client['vorname']) . " " . trim($client['name']) . " " . ($client['Firma'] ? " -- {$client['Firma']}" : "") : $cName;
					$returnData[$client['kundenid'] . " "]    = str_replace("&nbsp;", "   ", strip_tags(html_entity_decode($cName)));
				}
			}
			return $returnData;
		}
		
		public static function fetchMelanieFlowerShops(){
			/**@var \App\Entity\Personen[] $flowerShops */
			global $kernel;
			$rayFlowerShops = [];
			$entityManager  = $kernel->getContainer()->get('doctrine.orm.entity_manager');
			$flowerShops    = $entityManager->getRepository(Personen::class)
			                                ->findBy(['Kategorie' => 6], ['kundenid'=>'DESC']);
			if($flowerShops){
				foreach($flowerShops as $flowerShop){
					$rayFlowerShops[$flowerShop->getKundenid()] = $flowerShop->getName();
				}
			}
			return $rayFlowerShops;
		}
		
		public static function fetchDepartmentsAsOptions(){
			/**@var \App\Entity\Personen[] $flowerShops */
			global $kernel;
			$rayFlowerShops = [];
			$entityManager  = $kernel->getContainer()->get('doctrine.orm.entity_manager');
			$flowerShops    = $entityManager->getRepository(Personen::class)
			                                ->findBy(['Kategorie' => 6], ['kundenid'=>'DESC']);
			if($flowerShops){
				$rayFlowerShops['0'] = 'alle';
				foreach($flowerShops as $flowerShop){
					if($flowerShop->getKundenid() == '942' || $flowerShop->getKundenid() == '2621' ) { continue; }
					$rayFlowerShops[$flowerShop->getKundenid()] = $flowerShop->getName();
				}
			}
			return $rayFlowerShops;
		}
		
		public static function fetchHourIndexIntervalAsOptions(){
			$intervalOptions = [];      // ["", "Minuten wählen"];
			for($i = 0; $i<=23; $i++){
				$intervalOptions["{$i}"]  = "{$i} Uhr";
			}
			return $intervalOptions;
		}
		
		public static function fetchMinuteIndexIntervalAsOptions(){
			$intervalOptions = [];  // ["", "Minuten wählen"];
			for($i = 0; $i<=55; $i*=5){
				$intervalOptions["{$i}"]  = "{$i} Min.";
			}
			return $intervalOptions;
		}
		
		public static function fetchDropDownOptionsByClassGivenValue(){
			/** @var \Doctrine\ORM\EntityManager $entityManager */
			/** @var \App\Entity\TicketPrio $ticketPriority */
			global $kernel;
			$entityManager        = $kernel->getContainer()->get('doctrine.orm.entity_manager');
			$rayTicketPriorities  = [];
			$ticketPriorities     = $entityManager->
			getRepository(TicketPrio::class)->findBy([], ['ticket_prio_id'=>'ASC']);  // ticket_prio_name  ticket_prio_id
			if($ticketPriorities){
				# $rayTicketPriorities[""] = "Priorität wählen...";
				foreach($ticketPriorities as $ticketPriority){
					$rayTicketPriorities[$ticketPriority->getTicketPrioId()] = $ticketPriority->getTicketPrioName();
				}
			}
			return $rayTicketPriorities;
		}
		
		public static function fetchCoWorkers() {
			/** @var \Doctrine\ORM\EntityManager $entityManager */
			/** @var \App\Entity\Personen $coWorker */
			global $kernel;
			$entityManager  = $kernel->getContainer()->get('doctrine.orm.entity_manager');
			$rayCoWorkers   = [];
			$coWorkers      = $entityManager->
			getRepository(Personen::class)->
			findBy(
				['Kategorie' => '10', 'deleted' => 0],
				[
					'vorname'  => 'ASC',
					'name'      => 'ASC',
					'kundenid'  => 'ASC',
				]
			);
			if($coWorkers){
				$rayCoWorkers[" "] = "Mitarbeiter wählen...";   // ADDED TO HAVE A FALL-BACK EMPTY VALUE...
				foreach($coWorkers as $coWorker){
					$rayCoWorkers[$coWorker->getKundenid()] = $coWorker->getVorname() . " " . $coWorker->getName();
				}
			}
			return $rayCoWorkers;
		}
		
		public static function fetchKnowledgeRightsAsOptions() {
		return [
					'0'   => '0',
					'1'   => '1',
					'2'   => '2',
					'10'  => '10',
				];
		}
		
		public static function fetchTicketYesNoOptions(){
			return [
				'0' => 'Nein',
				'1' => 'Ja'
			];
		}
		
		/**
		 */
		public static function fetchBillPSAsOptions() {
			/** @var \Doctrine\ORM\EntityManager $entityManager */
			/** @var \App\Entity\RechnungPs $rp */
			global $kernel;
			$entityManager  = $kernel->getContainer()->get('doctrine.orm.entity_manager');
			$rayRps         = [];
			
			$rps            = $entityManager->
			getRepository(RechnungPs::class)-> findAll();
			if($rps){
				# $rayRps[""] = "PS wählen...";
				foreach($rps as $rp){
					$rayRps[$rp->getRechnungPsId()] = $rp->getRechnungPsHeader();
				}
			}
			return $rayRps;
		}
		
		public static function fetchBillStatusesAsOptions() {
			/** @var \Doctrine\ORM\EntityManager $entityManager */
			/** @var \App\Entity\RechnungStatus $rp */
			global $kernel;
			$entityManager  = $kernel->getContainer()->get('doctrine.orm.entity_manager');
			$rayRps         = [];
			
			$rps            = $entityManager->
			getRepository(RechnungStatus::class)-> findAll();
			if($rps){
				# $rayRps[""] = "PS wählen...";
				foreach($rps as $rp){
					$rayRps[$rp->getRechnungStatusId()] = $rp->getRechnungStatusName();
				}
			}
			return $rayRps;
		}
	}